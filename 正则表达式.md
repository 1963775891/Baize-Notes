# 常用正则表达式

## 1. 基本匹配

正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 `the`，它表示一个规则：由字母t开始，接着是h，再接着是e。

```javascript
"the" => The fat cat sat on the mat.
```

正则表达式123匹配字符串123。它逐个字符的与输入的正则表达式做比较。

正则表达式是大小写敏感的，所以`The`不会匹配`the`。

```javascript
"The" => The fat cat sat on the mat.
```

## 2. 元字符

正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：

| 元字符 | 描述                                                       |
| ------ | ---------------------------------------------------------- |
| .      | 句号匹配任意单个字符除了换行符。                           |
| [ ]    | 字符种类。匹配方括号内的任意字符。                         |
| [^ ]   | 否定的字符种类。匹配除了方括号里的任意字符                 |
| *      | 匹配>=0个重复的在*号之前的字符。                           |
| +      | 匹配>=1个重复的+号前的字符。                               |
| ?      | 标记?之前的字符为可选.                                     |
| {n,m}  | 匹配num个大括号之前的字符或字符集 (n <= num <= m).         |
| (xyz)  | 字符集，匹配与 xyz 完全相等的字符串.                       |
| \|     | 或运算符，匹配符号前或后的字符.                            |
| \\     | 转义字符，用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \ |
| ^      | 从开始行开始匹配.                                          |
| $      | 从末端开始匹配.                                            |

### 2.1 点运算符 .

.是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式`.ar`匹配一个任意字符后面跟着是a和r的字符串。

```javascript
".ar" => The car parked in the garage.
```

### 2.2 字符集

字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式`[Tt]he`匹配`the`和`The`。

```javascript
"[Tt]he" => The car parked in the garage.
```

方括号的句号就表示句号。 表达式`ar[.]`匹配`ar.`字符串。

```javascript
"ar[.]" => A garage is a good place to park a car.
```

#### 2.2.1 否定字符集

一般来说 `^` 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式`[^c]ar`匹配一个后面跟着ar的除了c的任意字符。

```javascript
"[^c]ar" => The car parked in the garage.
```

### 2.3 重复次数

后面跟着元字符 `+`，`*` or `?` 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。

### 2.3.1 * 号

*号匹配 在*之前的字符出现大于等于0次。 例如，表达式`a*`匹配0或更多个以a开头的字符。表达式`[a-z]*`匹配一个行中所有以小写字母开头的字符串。

```javascript
"[a-z]*" => The car parked in the garage #21.
```

*字符和.字符搭配可以匹配所有的字符.*。*和表示匹配空格的符号`\s`连起来用，如表达式`\s*cat\s*`匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。

```javascript
"\s*cat\s*" => The fat cat sat on the concatenation.
```

### 2.3.2 + 号

+号匹配+号之前的字符出现 >=1 次。 例如表达式`c.+t`匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。

```javascript
"c.+t" => The fat cat sat on the mat.
```

### 2.3.3 ? 号

在正则表达式中元字符`?`标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式`[T]?he`匹配字符串`he`和`The`。

```javascript
"[T]?he" => The car is parked in the garage.
```

### 2.4 {} 号

在正则表达式中 `{}` 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式`[0-9]{2,3}` 匹配最少 2 位最多 3 位 0~9 的数字。

```javascript
"[0-9]{2,3}" => The number was 9.9997 but we rounded it off to 10.0.
```

我们可以省略第二个参数。 例如，`[0-9]{2,}` 匹配至少两位 0~9 的数字。

```javascript
"[0-9]{2,}" => The number was 9.9997 but we rounded it off to 10.0.
```

如果逗号也省略掉则表示重复固定的次数。 例如，`[0-9]{3}` 匹配3位数字

```javascript
"[0-9]{3}" => The number was 9.9997 but we rounded it off to 10.0.
```

### 2.5 (...) 特征标群

特征标群是一组写在 (...)中的子模式。(...)中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式`(ab)*` 匹配连续出现 0 或更多个 ab。如果没有使用 (...)，那么表达式`ab*` 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 用来表示前面一个字符出现指定次数。但如果在 {}前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。

我们还可以在 ()中用或字符`|`表示或。例如，`(c|g|p)ar` 匹配 car 或 gar 或 par.

```javascript
"(c|g|p)ar" => The car is parked in the garage.
```

### 2.6 | 或运算符

或运算符就表示或，用作判断条件。

例如 `（T|t）he|car` 匹配 `（T|t）he` 或 `car`。

```javascript
"(T|t)he|car" => The car is parked in the garage.
```

### 2.7 转码特殊字符

反斜线 `\` 在表达式中用于转码紧跟其后的字符。用于指定 `{ } [ ] / \ + * . $ ^ | ?` 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 `\`。

例如 `.` 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 `.` 则要写成 `\.`。以下这个例子 `\.?` 是选择性匹配。

```javascript
"(f|c|m)at\.?" => The fat cat sat on the mat.
```

### 2.8 锚点

在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。 `^` 指定开头，`$` 指定结尾。

### 2.8.1 ^ 号

^ 用来检查匹配的字符串是否在所匹配字符串的开头。

例如，在 `abc` 中使用表达式 `^a` 会得到结果 `a`。但如果使用 `^b` 将匹配不到任何结果。因为在字符串 `abc` 中并不是以 `b` 开头。

例如，`^(T|t)he` 匹配以 `The` 或 `the` 开头的字符串。

```
"^(T|t)he" => The car is parked in the garage.
```

### 2.8.2 $ 号

同理于 `^` 号，`$` 号用来匹配字符是否是最后一个。

例如，`(at\.)$` 匹配以 `at.` 结尾的字符串。

```javascript
"(at\.)$" => The fat cat. sat. on the mat.
```

## 3. 简写字符集

正则表达式提供一些常用的字符集简写。如下：

| 简写 | 描述 |
| --- | --- |
| . | 除换行符外的所有字符 |
| \\w | 匹配所有字母数字，等同于 [a-zA-Z0-9_] |
| \\W | 匹配所有非字母数字，即符号，等同于：[^\\w] |
| \\d | 匹配数字：[0-9] |
| \\D | 匹配非数字：[^\\d] |
| \\s | 匹配所有空格字符，等同于：[\\t\\n\\f\\r\\p{Z}] |
| \\S | 匹配所有非空格字符：[^\\s] |
| \\f | 匹配一个换页符 |
| \n | 匹配一个换行符 |
| \\r | 匹配一个回车符 |
| \\t | 匹配一个制表符 |
| \\v | 匹配一个垂直制表符 |
| \\p | 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 |

## 4. 零宽度断言（前后预查）

先行断言和后发断言（合称 lookaround）都属于非捕获组（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。

例如，我们希望从下面的输入字符串 $4.44 和 $10.88 中获得所有以 $ 字符开头的数字，我们将使用以下的正则表达式 (?<=$)[0-9\.]*。意思是：获取所有包含 . 并且前面是 $ 的数字。

零宽度断言如下：

| 符号 | 描述 |
| --- | --- |
| ?= | 正先行断言-存在 |
| ?! | 负先行断言-排除 |
| ?<= | 正后发断言-存在 |
| ?<! | 负后发断言-排除 |

### 4.1 ?=... 正先行断言

?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=... 定义的表达式。

返回结果只包含满足匹配条件的第一部分表达式。定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号：(?=...)。

正先行断言的内容写在括号中的等号后面。例如，表达式 (T|t)he(?=\sfat) 匹配 The 和 the，在括号中我们又定义了正先行断言 (?=\sfat)，即 The 和 the 后面紧跟着 (空格)fat。

```javascript
"(T|t)he(?=\\sfat)" => The fat cat sat on the mat.
```

### 4.2 ?!... 负先行断言

负先行断言 ?! 用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。

正先行断言定义和负先行断言一样，区别就是 = 替换成 ! 也就是 (?!...)。

```javascript
//表达式 (T|t)he(?!\\sfat) 匹配 The 和 the，且其后不跟着 (空格)fat。

"(T|t)he(?!\\sfat)" => The fat cat sat on the mat.
```




### 4.3 ?<= ... 正后发断言

正后发断言记作(?<=...) 用于筛选所有匹配结果，筛选条件为其前跟随着断言中定义的格式。

```javascript
//例如，表达式 (?<=(T|t)he\\s)(fat|mat) 匹配 fat 和 mat，且其前跟着 The 或 the。

"(?<=(T|t)he\\s)(fat|mat)" => The fat cat sat on the mat.
```


### 4.4 ?<!... 负后发断言

负后发断言记作 (?<!...) 用于筛选所有匹配结果，筛选条件为其前不跟随着断言中定义的格式。

例如，表达式 (?<!(T|t)he\\s)(cat) 匹配 cat，且其前不跟着 The 或 the。

```javascript
"(?<!(T|t)he\\s)(cat)" => The cat sat on cat.
```


## 5. 标志

标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。

| 标志 | 描述 |
| --- | --- |
| i | 忽略大小写。 |
| g | 全局搜索。 |
| m | 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 |

### 5.1 忽略大小写 (Case Insensitive)

修饰语 i 用于忽略大小写。

例如，表达式 /The/gi 表示在全局搜索 The，在后面的 i 将其条件修改为忽略大小写，则变成搜索 the 和 The，g 表示全局搜索。

```javascript
"The" => The fat cat sat on the mat.

"/The/gi" => The fat cat sat on the mat.
```


### 5.2 全局搜索 (Global search)

修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。

例如，表达式 /.(at)/g 表示搜索 任意字符（除了换行）+ at，并返回全部结果。

```javascript
"/.(at)/" => The fat cat sat on the mat.

"/.(at)/g" => The fat cat sat on the mat.
```


### 5.3 多行修饰符 (Multiline)

多行修饰符 m 常用于执行一个多行匹配。

像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。

例如，表达式 /at(.)?$/gm 表示小写字符 a 后跟小写字符 t ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。

```javascript
"/.at(.)?$/" => The fat
                  cat sat
                  on the mat.

"/.at(.)?$/gm" => The fat
                   cat sat
                   on the mat.
```


## 6. 贪婪匹配与惰性匹配 (Greedy vs lazy matching)

正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。

```javascript
"/(.*at)/" => The fat cat sat on the mat.

"/(.*?at)/" => The fat cat sat on the mat.
```

------



| 表达式全集 | 描述 |
| --- | --- |
| \ | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\\”匹配“\\”而“\\(”则匹配“(”。 |
| ^ | 匹配输入字符串的开始位置。如果设置了Reg Exp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 |
| $ | 匹配输入字符串的结束位置。如果设置了Reg Exp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 |
| * | 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于{0,}。 |
| + | 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 |
| ? | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于{0,1}。 |
| {n} | n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 |
| {n,} | n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 |
| {n,m} | m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| ? | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。 |
| . | 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“^." |
| (pattern) | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用Sub Matches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。 |
| (?:pattern) | 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|
| (?=pattern) | 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|
| (?!pattern) | 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|
| (?<=pattern) | 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?<=95|
| (?<!pattern) | 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?<!95|
| x|y |
| [xyz] | 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 |
| [^xyz] | 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。 |
| [a-z] | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 |
| [^a-z] | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 |
| \b | 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 |
| \B | 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 |
| \cx | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 |
| \d | 匹配一个数字字符。等价于[0-9]。 |
| \D | 匹配一个非数字字符。等价于[^0-9]。 |
| \f | 匹配一个换页符。等价于\x0c和\cL。 |
| \n | 匹配一个换行符。等价于\x0a和\cJ。 |
| \r | 匹配一个回车符。等价于\x0d和\cM。 |
| \s | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| \S | 匹配任何非空白字符。等价于[^ \f\n\r\t\v]。 |
| \t | 匹配一个制表符。等价于\x09和\cI。 |
| \v | 匹配一个垂直制表符。等价于\x0b和\cK。 |
| \w | 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。 |
| \W | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。 |
| \xn | 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04\u00261”。正则表达式中可以使用ASCII编码。 |
| \num | 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。 |
| \n | 标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。 |
| \nm | 标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后|
